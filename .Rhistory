matplot(t,aux_s, type = "l")
mwp = rep(0,length(Y)) # mu weights prior
swp = diag(length(Y)) # sigma weights prior
M <- mu_function(X)
kXX <- matrix(NA, length(X), length(X))
for(i in 1:length(X)){
for(j in i:length(X)){
kXX[i,j] <- kernel_function(c(X[i], X[j]), ref_points)
kXX[j,i] <- kXX[i,j]}
}
G <- kXX + 0.5^2*diag(length(X))
R <- chol(G, LINPACK = TRUE)
phiX <- matrix(NA, length(ref_points), length(X))
for(i in 1:length(X)){
phiX[,i] <- phi_function(X[i], ref_points)
}
A = swp %*% phiX %*% chol2inv(R, LINPACK = TRUE)
# pdf posterior for w given Y and phiX: w|Y,phiX ~ N(mpost_w, vpost_w)
mpost_w = mwp + A %*% (Y-M)
vpost_w = swp - A %*% t(phiX) %*% swp
dmvnorm(Y, mpost_w, vpost_w)
kxX <- matrix(NA, length(t), length(X))
for(i in 1:length(t)){
for(j in 1:length(X)){
kxX[i,j] <- kernel_function(c(t[i],X[j]),ref_points)
}
}
A = kxX %*% solve(R)
mpostx = m + A %*% solve(t(R) , (Y-M))
vpostx = ktt - A %*% t(A)
# drawing from the posterior fx
cov_post <- chol(vpostx + 1e-08*diag(length(t)))
aux_spost <- rmvnorm(3, rep(0,length(t)))
aux_spost <- t(cov_post) %*% t(aux_spost)
aux_spost <- cbind(mpostx, mpostx, mpostx) + aux_spost
matplot(t,aux_spost, type = "l")
points(X,Y, col = "red")
mwp = rep(0,length(Y)) # mu weights prior
swp = diag(length(Y)) # sigma weights prior
M <- mu_function(X)
kXX <- matrix(NA, length(X), length(X))
for(i in 1:length(X)){
for(j in i:length(X)){
kXX[i,j] <- kernel_function(c(X[i], X[j]), ref_points)
kXX[j,i] <- kXX[i,j]}
}
G <- kXX + 0.01^2*diag(length(X))
R <- chol(G, LINPACK = TRUE)
phiX <- matrix(NA, length(ref_points), length(X))
for(i in 1:length(X)){
phiX[,i] <- phi_function(X[i], ref_points)
}
A = swp %*% phiX %*% chol2inv(R, LINPACK = TRUE)
# pdf posterior for w given Y and phiX: w|Y,phiX ~ N(mpost_w, vpost_w)
mpost_w = mwp + A %*% (Y-M)
vpost_w = swp - A %*% t(phiX) %*% swp
dmvnorm(Y, mpost_w, vpost_w)
## pdf posterior for fx given Y and phiX: fx|Y,phiX ~ N(mpostx, vpostx)
kxX <- matrix(NA, length(t), length(X))
for(i in 1:length(t)){
for(j in 1:length(X)){
kxX[i,j] <- kernel_function(c(t[i],X[j]),ref_points)
}
}
A = kxX %*% solve(R)
mpostx = m + A %*% solve(t(R) , (Y-M))
vpostx = ktt - A %*% t(A)
# drawing from the posterior fx
cov_post <- chol(vpostx + 1e-08*diag(length(t)))
aux_spost <- rmvnorm(3, rep(0,length(t)))
aux_spost <- t(cov_post) %*% t(aux_spost)
aux_spost <- cbind(mpostx, mpostx, mpostx) + aux_spost
matplot(t,aux_spost, type = "l")
points(X,Y, col = "red")
ref_points <- t_0
X <- t_0
# we set the same values for Y as in python code
Y <- estim_zeta_t_0
# feature function
# ref_points are the midpoints of the bins in the histogram for example
phi_function <- function(t, ref_points) {
x <- vector(length = length(ref_points))
for(i in 1:length(x)) x[i] <- exp(-0.5*(t-ref_points[i])^2)
return(as.matrix(x))
}
# the kernel to calculate the covariance function
kernel_function <- function(t, ref_points) t(phi_function(t[1], ref_points)) %*%
phi_function(t[2], ref_points) # kernel
mu_function <- function(t) as.matrix(rep(0, length(t)))
t <- as.matrix(seq(0,13.8, length = 100))
m <- mu_function(t)
m
ktt <- matrix(NA, length(t), length(t))
for(i in 1:length(t)){
for(j in i:length(t)){
ktt[i,j] <- kernel_function(c(t[i], t[j]), ref_points)
ktt[j,i] <- ktt[i,j]
}
}
cov_matrix <- chol(ktt + 1e-08*diag(length(t)))
aux_s <- rmvnorm(3, rep(0,length(t)))
aux_s <- t(cov_matrix) %*% t(aux_s)
matplot(t,aux_s, type = "l")
mwp = rep(0,length(Y)) # mu weights prior
swp = diag(length(Y)) # sigma weights prior
M <- mu_function(X)
kXX <- matrix(NA, length(X), length(X))
for(i in 1:length(X)){
for(j in i:length(X)){
kXX[i,j] <- kernel_function(c(X[i], X[j]), ref_points)
kXX[j,i] <- kXX[i,j]}
}
G <- kXX + 0.01^2*diag(length(X))
R <- chol(G, LINPACK = TRUE)
phiX <- matrix(NA, length(ref_points), length(X))
for(i in 1:length(X)){
phiX[,i] <- phi_function(X[i], ref_points)
}
A = swp %*% phiX %*% chol2inv(R, LINPACK = TRUE)
# pdf posterior for w given Y and phiX: w|Y,phiX ~ N(mpost_w, vpost_w)
mpost_w = mwp + A %*% (Y-M)
vpost_w = swp - A %*% t(phiX) %*% swp
postw_samples <- rmvnorm(n = 3, mpost_w, vpost_w)
str(postw_samples)
kxX <- matrix(NA, length(t), length(X))
for(i in 1:length(t)){
for(j in 1:length(X)){
kxX[i,j] <- kernel_function(c(t[i],X[j]),ref_points)
}
}
A = kxX %*% solve(R)
mpostx = m + A %*% solve(t(R) , (Y-M))
vpostx = ktt - A %*% t(A)
# drawing from the posterior fx
cov_post <- chol(vpostx + 1e-08*diag(length(t)))
aux_spost <- rmvnorm(3, rep(0,length(t)))
aux_spost <- t(cov_post) %*% t(aux_spost)
aux_spost <- cbind(mpostx, mpostx, mpostx) + aux_spost
str(aux_spost)
post_zeta <- as.data.frame(aux_spost)
colnames(post_zeta) <- c("z_1", "z_2", "z_3")
str(post_zeta)
post_zeta$t <- t
post_zeta1 <- melt(post_zeta, id = "t")
require(reshape2)
post_zeta1 <- melt(post_zeta, id = "t")
str(post_zeta1)
ggplot(data = data.frame(x = t_0, y = estim_zeta_t_0), aes(x,y)) +
geom_histogram(data = data.frame(x = (13.8-true_ages)), aes(y = ..density..),
fill = "white", binwidth = 1, color = "gray", alpha = 0.7) +
geom_line(data = true_sfr, aes(x,y), alpha = 0.3) +
geom_point(col = "blue", shape =1) +
geom_errorbar(limits, width=0.25) +
scale_x_continuous("time-Gyr") +
scale_y_continuous("sfr")
ggplot(data = data.frame(x = t_0, y = estim_zeta_t_0), aes(x,y)) +
geom_histogram(data = data.frame(x = (13.8-true_ages)), aes(y = ..density..),
fill = "white", binwidth = 1, color = "gray", alpha = 0.7) +
geom_line(data = true_sfr, aes(x,y), alpha = 0.3) +
geom_point(col = "blue", shape =1) +
geom_errorbar(limits, width=0.25) +
geom_line(data = post_zeta1, aes(t,value, color = variable))+
scale_x_continuous("time-Gyr") +
scale_y_continuous("sfr")
library(laeken2)
install.packages("tools")
install.packages("tools")
install.packages("tools")
install.packages("tools")
install.packages("tools")
install.packages("tools")
install.packages("tools")
libray(knitr)
library(knitr)
install.packages("knitr")
library(knitr)
devtools::install_github("hadley/staticdocs")
devtools::install_github("hadley/staticdocs")
library(laeken2)
?gini
# PDF para la SFR
gamma <- 0.12 # parametro que tendremos que recuperar
sfrpdf <- function(t) gamma/(1-exp(-13.8*gamma)) * exp(-gamma * t)
sfrpdf(4)
sfrcdf <- function(y) (1-exp(-gamma * y))/(1-exp(-13.8*gamma))
sfrcdf(4)
sfr_invcdf <- function(u) -log(1 - u*(1-exp(-13.8*gamma)))/gamma
sfr_invcdf(0.5)
# Optamos por IMF de tres pendientes.
# constantes para que la pdf integre a 1 en su soporte [M1,M4]
constants <- function(alpha, M){
pow <- function(x,y) x^y
M1 <- M[1]
M2 <- M[2]
M3 <- M[3]
M4 <- M[4]
gluepoint1 <- M2
gluepoint2 <- M3
a1 <- alpha[1]
a2 <- alpha[2]
a3 <- alpha[3]
A <- matrix(NA, 3, 3)
A[1,1] <- pow(gluepoint1, -a1)
A[1,2] <- -pow(gluepoint1, -a2)
A[1,3] <- 0
A[2,1] <- 0
A[2,2] <- pow(gluepoint2, -a2)
A[2,3] <- -pow(gluepoint2, -a3)
A[3,1] <- (pow(M2, (1-a1))-pow(M1, (1-a1)))/(1-a1)
A[3,2] <- (pow(M3, (1-a2))-pow(M2, (1-a2)))/(1-a2)
A[3,3] <- (pow(M4, (1-a3))-pow(M3, (1-a3)))/(1-a3)
b <- c(0,0,1)
cons <- solve(A,b)
return(cons)
}
init_alphas = c(1.3, 2.3, 2.3)
init_m1 = 0.01
init_m2 = 0.5
init_m3 = 2.0
init_m4 = 120
init_m_bounds <- c(init_m1, init_m2, init_m3, init_m4)
init_cons <- constants(init_alphas, init_m_bounds)
init_cons
imf_invcdf <- function(x, alpha, M, cons){ # Analytic inverse CDF
a1 <- alpha[1]
a2 <- alpha[2]
a3 <- alpha[3]
M1 <- M[1]
M2 <- M[2]
M3 <- M[3]
M4 <- M[4]
c1 <- cons[1]
c2 <- cons[2]
c3 <- cons[3]
x1 <- (c1/(1-a1))*(M2^(1-a1)-M1^(1-a1))
x2 <- (c2/(1-a2))*(M3^(1-a2)-M2^(1-a2))
if(x<x1){
m <- ((1-a1)*x/c1+M1^(1-a1))^(1/(1-a1))
}else if(x1<x & x<(x1+x2)){
m <- ((x-x1)*(1-a2)/c2+M2^(1-a2))^(1/(1-a2))
}else{
m <- ((x-x1-x2)*(1-a3)/c3+M3^(1-a3))^(1/(1-a3))
}
return(m)
}
imf_invcdf(0.5, init_alphas, init_m_bounds, ini)
imf_invcdf(0.5, init_alphas, init_m_bounds, init_cons)
summary(rlnorm(1000))
summary(rlnorm(1000,meanlog = 0, sdlog = 0.1))
summary(rlnorm(1000,meanlog = log(1), sdlog = 0.1))
summary(rlnorm(1000,meanlog = log(50), sdlog = 0.1))
install.packages("Rcmdr")
q()
install.packages("car")
install.packages("pbkrtest")
info()
?info
??info
library(devtools)
session_info()
q()
install.packages("car")
install.packages("car")
install.packages("Rcmdr")
library(Rcmdr)
?poly
q()
library(rtip)
1/seq(0.125, 3.5, by = 0.01)
x <- scan()
sd(x)
sqrt(4/4)*sd(x)
sqrt(4/5)*sd(x)
law <- function(x, R_v){
if(0.3<=x & x <1.1){
ax <- 0.574*x^(1.61)
bx <- -0.527*x^(1.61)
return(ax + bx/R_v)
}else if(1.1 < x & x <=3.3){
y <- x-1.82
ax <- 1 + 0.17699*y - 0.50447*y^2 - 0.02427*y^3 +
0.72085*y^4 + 0.01979*y^5 - 0.77530*y^6 + 0.32999*y^7
bx <- 1.41338*y + 2.28305*y^2 + 1.07233*y^3 -
5.38434*y^4 - 0.62251*y^5 + 5.30260*y^6 - 2.09002*y^7
return(ax+bx/R_v)
}
}
ext.law <- function(R_v){
x <- seq(0.3, 3.3, length.out = 100)
y <- adply(x, .margins = 1, law, R_v)
return(y[,2])
}
# Infrared --------------------------------------------------------------
library(plyr)
library(reshape2)
library(ggplot2)
R_v <- as.matrix(seq(2,5, by = 0.25))
ext.laws <- aaply(R_v,1,ext.law)
inv.lambda <- seq(0.3, 3.3, length.out = 100)
dataset <- as.data.frame(cbind(inv.lambda, t(ext.laws)))
dataset2 <- melt(dataset, id = "inv.lambda")
ggplot(dataset2, aes(inv.lambda, value, color = variable)) + geom_line()
# Adding magnitudes in study
event <- c("I", "Z", "Y", "J", "H", "K")
mag <- 1/c(0.806, 0.9, 1.020, 1.220, 1.630, 2.190)
lab <- data.frame(cbind(mag, event))
ggplot(dataset2, aes(inv.lambda, value, color = variable)) + geom_line() +
geom_vline(xintercept = mag, color ="blue") +
scale_x_continuous(breaks = sort(c(seq(min(dataset2$inv.lambda), max(dataset2$inv.lambda), length.out=5), mag)))
devtools::install_github("rstudio/rticles")
library(devtools)
install_github("rstudio/rticles")
install.packages("rticles", type = "source")
library(rticles)
x <- 1:10
x
library(Rcmdr)
knit_with_parameters('~/pract3/pract3.Rmd')
?poisson
?ppois
ppois(3,5)
install.packages("tufte", type = "source")
5*log10(116.56)-5 = 18.79
5*log10(116.56)-5 = 18.79
5*log10(116.56)-5
cte_boltzmann <- 5.670373e-8
cte_boltzmann
luminosity <- function(radii, temperature){
cte_boltzmann <- 5.670373e-8 # W m^-2 K^-4
lum <- 4*pi*radii^2*cte_boltzmann*temperature^4
return(lum)
}
tempK <- seq(2300, 40000, by = 100)
library(ggplot2)
library(FITSio)
library(gridExtra)
library(devtools)
library(grid)
library(ggplot2)
library(Rcmdr)
local({
.x <- 34:66
plotDistr(.x, dbinom(.x, size=100, prob=0.5), xlab="Number of Successes",
ylab="Probability Mass",
main="",
discrete=TRUE)
})
local({
.x <- 34:66
plotDistr(.x, dbinom(.x, size=100, prob=0.5), xlab="Number of Successes",
ylab="Probability Mass",
main="",
discrete=TRUE)
})
.x <- 34:66
plotDistr(.x, dbinom(.x, size=100, prob=0.5), xlab="Number of Successes",
ylab="Probability Mass",
main="",
discrete=TRUE)
.x <- 34:66
plotDistr(.x, dbinom(.x, size=100, prob=0.5), xlab="Number of Successes",
ylab="Probability Mass",
main="",
discrete=TRUE)
dbinom()
library(Rcmdr)
library(Rcmdr)
library(Rcmdr)
citation("rtip")
install.packages("rtip")
citation("rtip")
?load
?read.csv
btsettl = read.table('/home/angel/ownCloud/Research/ANGEL-DANCE/USCO/extinction/datasets/model.BT-Settl-6Myr.csv', delimiter=",")
btsettl = read.table('/home/angel/ownCloud/Research/ANGEL-DANCE/USCO/extinction/datasets/model.BT-Settl-6Myr.csv')
str(btsettl)
btsettl = read.table('/home/angel/ownCloud/Research/ANGEL-DANCE/USCO/extinction/datasets/model.BT-Settl-6Myr.csv',
header = TRUE)
str(btsettl)
btsettl = read.table('/home/angel/ownCloud/Research/ANGEL-DANCE/USCO/extinction/datasets/model.BT-Settl-6Myr.csv',
header = TRUE, sep =",")
head(btsettl)
X = btsettl['i_Ks']
head(btsettl)
X = btsettl['i'] - btsettl['Ks']
X = btsettl['i_sdss'] - btsettl['Ks']
Y = btsettl['Ks']
btsettl = read.table('/home/angel/ownCloud/Research/ANGEL-DANCE/USCO/extinction/datasets/model.BT-Settl-6Myr.csv',
header = TRUE, sep =",")
X = btsettl['i_sdss'] - btsettl['Ks']
Y = btsettl['Ks']
porder = 2
phi_function <- function(t) {
x <- vector(length = porder))
for(i in 1:length(porder) x[i] <- t^(porder-1)
return(as.matrix(x))
}
phi_function <- function(t) {
porder = 2
x <- vector(length = porder)
for(i in 1:length(porder) x[i] <- t^(porder-1)
return(as.matrix(x))
}
phi_function <- function(t) {
porder = 2
x <- vector(length = porder)
for(i in 1:length(porder)) x[i] <- t^(porder-1)
return(as.matrix(x))
}
# the kernel to calculate the covariance function
kernel_function <- function(t) t(phi_function(t[1])) %*%  phi_function(t[2]) # kernel
# mean function
mu_function <- function(t) as.matrix(rep(0, length(porder)))
t <- as.matrix(seq(1,10, length = 100))
m <- mu_function(t)
ktt <- matrix(NA, length(t), length(t))
dim(ktt)
ktt
length(t)
t
for(i in 1:length(t)){
for(j in i:length(t)){
ktt[i,j] <- kernel_function(c(t[i], t[j]))
ktt[j,i] <- ktt[i,j]
}
}
ktt
dim(ktt)
ktt[1,]
ktt[11]
ktt[,1]
t
t[1]
head(t)
phi_function(1)
phi_function(2)
phi_function(3)
phi_function <- function(t) {
porder = 2
x <- vector(length = porder)
for(i in 1:length(porder)) x[i] <- t^(porder-i)
return(as.matrix(x))
}
phi_function(3)
phi_function(2)
phi_function <- function(t) {
porder = 2
x <- vector(length = porder)
for(i in 1:length(porder)) x[i] <- t^i
return(as.matrix(x))
}
phi_function(2)
porder = 2
length(porder)
phi_function <- function(t) {
porder = 2
x <- vector(length = porder)
for(i in 1:porder) x[i] <- t^i
return(as.matrix(x))
}
phi_function(2)
phi_function <- function(t) {
porder = 2
x <- vector(length = porder)
for(i in 1:porder) x[i] <- t^(i-1)
return(as.matrix(x))
}
phi_function(2)
ktt <- matrix(NA, length(t), length(t))
for(i in 1:length(t)){
for(j in i:length(t)){
ktt[i,j] <- kernel_function(c(t[i], t[j]))
ktt[j,i] <- ktt[i,j]
}
}
ktt[1,]
ktt[,1]
start <- as.Date('2015-05-01')
today <- as.Date('2015-06-27')
all_days <- seq(start, today, by = 'day')
year <- as.POSIXlt(all_days)$year + 1900
urls <- paste0('http://cran-logs.rstudio.com/', year, '/', all_days, '.csv.gz')
library(rtip)
?rtip
??rtip
?arpr
6000/14827
devtools::install_github("crsh/citr")
.Options$unzip
devtools::install_github("rstudio/rticles")
library(rticles)
setwd("~/Dropbox/Research/Proyecto/rtip-paper")
setwd("~/Dropbox/Research/Proyecto/SEIO2016")
knit_with_parameters('~/Documentos/testPresentation/test1.Rmd')
library(rtip)
?arpt
install.packages("slidifyLibraries", "ramnathv")
library(devtools)
install_github("slidifyLibraries", "ramnathv")
knit_with_parameters('~/Dropbox/Research/Proyecto/SEIO2016/rtip-presentation.Rmd')
knit_with_parameters('~/Dropbox/Research/Proyecto/SEIO2016/rtip-presentation.Rmd')
slidifyDefaults()
library(slidify)
slidifyDefaults()
slidify('rtip-presentation.Rmd')
slidify('rtip-presentation.Rmd')
slidify('rtip-presentation.Rmd')
author("demo")
slidify('rtip-presentation.Rmd')
setwd("~/Dropbox/Research/Proyecto/SEIO2016")
author("rtip2")
library(rtip)
